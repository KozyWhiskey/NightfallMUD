// server/src/game/gameEngine.ts

import { PrismaClient } from '@prisma/client';
import type { Player, Room, Item } from '@prisma/client'; // Import types generated by Prisma

// Command from client (no change)
export interface Command {
  action: string;
  payload?: any;
}

// Game event for client (no change)
export interface GameEvent {
  target: string;
  type: 'gameUpdate' | 'message';
  payload: any;
}

export class GameEngine {
  // Create a single instance of the Prisma Client
  private prisma = new PrismaClient();
  private startingRoomId = 'room-1';

  // --- Player Management (Now Async!) ---
  
  async addPlayer(playerId: string): Promise<GameEvent[]> {
    // Create a new Player record in the database
    const player = await this.prisma.player.create({
      data: {
        id: playerId,
        name: playerId, // Use ID as name for now
        currentRoomId: this.startingRoomId,
      },
    });

    const startingRoom = await this.prisma.room.findUnique({ where: { id: this.startingRoomId }});
    if (!startingRoom) throw new Error('Starting room not found!');

    const playersInRoom = await this.getPlayersInRoom(this.startingRoomId, playerId);

    // Announce arrival to others in the room
    const arrivalAnnouncement: GameEvent = {
      target: 'room',
      type: 'message',
      payload: {
        message: `${player.name} has entered the game.`,
        roomId: this.startingRoomId,
        exclude: [playerId]
      }
    };

    // Send initial state to the new player
    const selfWelcome: GameEvent = {
      target: playerId,
      type: 'gameUpdate',
      payload: {
        message: `Welcome, ${player.name}! You are in ${startingRoom.name}.`,
        room: startingRoom,
        players: playersInRoom.map(p => p.name),
        roomItems: await this.prisma.item.findMany({ where: { roomId: startingRoom.id }})
      }
    };
    
    return [arrivalAnnouncement, selfWelcome];
  }

  async removePlayer(playerId: string): Promise<GameEvent | null> {
    try {
      // We must find the player first to know their last room
      const player = await this.prisma.player.findUnique({ where: { id: playerId } });
      if (!player) return null;

      // Now delete them
      await this.prisma.player.delete({ where: { id: playerId } });
      
      return {
        target: 'room',
        type: 'message',
        payload: {
          message: `${player.name} has left the game.`,
          roomId: player.currentRoomId,
          exclude: []
        }
      };
    } catch(e) {
      console.error("Error removing player:", e);
      return null;
    }
  }

  // --- Command Processing (Now Async!) ---

  async processCommand(playerId: string, command: Command): Promise<GameEvent[]> {
    // Fetch the current player and their room in one go!
    const player = await this.prisma.player.findUnique({
      where: { id: playerId },
      include: { room: true },
    });

    if (!player || !player.room) return [];

    let events: GameEvent[] = [];
    const currentRoom = player.room;

    switch (command.action) {
      case 'look': {
        const playersInRoom = await this.getPlayersInRoom(currentRoom.id, playerId);
        const itemsInRoom = await this.prisma.item.findMany({ where: { roomId: currentRoom.id } });
        events.push({
          target: playerId,
          type: 'gameUpdate',
          payload: {
            message: 'You look around.',
            room: currentRoom,
            players: playersInRoom.map(p => p.name),
            roomItems: itemsInRoom,
          }
        });
        break;
      }

      case 'move': {
        const direction = command.payload;
        const exits = currentRoom.exits as { [key: string]: string }; // Type assertion
        const nextRoomId = exits[direction];

        if (nextRoomId) {
          events.push({ target: 'room', type: 'message', payload: { roomId: currentRoom.id, message: `${player.name} moves ${direction}.`, exclude: [playerId] }});
          
          const updatedPlayer = await this.prisma.player.update({
            where: { id: playerId },
            data: { currentRoomId: nextRoomId },
            include: { room: true }
          });
          const newRoom = updatedPlayer.room;
          if(!newRoom) throw new Error("Moved to a non-existent room!");

          const playersInNewRoom = await this.getPlayersInRoom(newRoom.id, playerId);
          const itemsInNewRoom = await this.prisma.item.findMany({ where: { roomId: newRoom.id } });

          events.push({ target: playerId, type: 'gameUpdate', payload: { message: `You move ${direction}.`, room: newRoom, players: playersInNewRoom.map(p => p.name), roomItems: itemsInNewRoom }});
          events.push({ target: 'room', type: 'message', payload: { roomId: newRoom.id, message: `${player.name} arrives.`, exclude: [playerId] }});

        } else {
          events.push({ target: playerId, type: 'message', payload: { message: "You can't go that way." } });
        }
        break;
      }
        
      case 'say': {
        const message = command.payload;
        if (message) {
          events.push({ target: playerId, type: 'message', payload: { message: `You say, '${message}'` }});
          events.push({ target: 'room', type: 'message', payload: { roomId: currentRoom.id, message: `${player.name} says, '${message}'`, exclude: [playerId] }});
        } else {
          events.push({ target: playerId, type: 'message', payload: { message: 'Say what?' } });
        }
        break;
      }
      
      case 'inventory':
      case 'i': {
        const playerInventory = await this.prisma.item.findMany({ where: { playerId: playerId }});
        let message = "You are carrying:\n";
        if (playerInventory.length === 0) {
          message = "You are not carrying anything.";
        } else {
          message += playerInventory.map(item => `  - ${item.name}`).join('\n');
        }
        events.push({ target: playerId, type: 'message', payload: { message }});
        break;
      }

      case 'get': {
        const itemName = command.payload;
        const item = await this.prisma.item.findFirst({ where: { name: { equals: itemName, mode: 'insensitive' }, roomId: currentRoom.id } });
        
        if (item) {
          // Update item to link to player instead of room
          await this.prisma.item.update({
            where: { id: item.id },
            data: { roomId: null, playerId: playerId }
          });
          events.push({ target: playerId, type: 'message', payload: { message: `You take the ${item.name}.` }});
          events.push({ target: 'room', type: 'message', payload: { roomId: currentRoom.id, message: `${player.name} takes the ${item.name}.`, exclude: [playerId] }});
        } else {
          events.push({ target: playerId, type: 'message', payload: { message: "You don't see that here." }});
        }
        break;
      }

      case 'drop': {
        const itemName = command.payload;
        const item = await this.prisma.item.findFirst({ where: { name: { equals: itemName, mode: 'insensitive' }, playerId: playerId } });

        if (item) {
          // Update item to link to room instead of player
          await this.prisma.item.update({
            where: { id: item.id },
            data: { playerId: null, roomId: currentRoom.id }
          });
          events.push({ target: playerId, type: 'message', payload: { message: `You drop the ${item.name}.` }});
          events.push({ target: 'room', type: 'message', payload: { roomId: currentRoom.id, message: `${player.name} drops a ${item.name}.`, exclude: [playerId] }});
        } else {
          events.push({ target: playerId, type: 'message', payload: { message: "You aren't carrying that." }});
        }
        break;
      }

      default:
        events.push({ target: playerId, type: 'message', payload: { message: 'Unknown command.' } });
        break;
    }
    return events;
  }

  // --- Utility Methods (Now Async!) ---
  
  async getPlayersInRoom(roomId: string, excludePlayerId?: string): Promise<Player[]> {
    const playersInRoom = await this.prisma.player.findMany({
      where: {
        currentRoomId: roomId,
        id: { not: excludePlayerId },
      },
    });
    return playersInRoom;
  }
}